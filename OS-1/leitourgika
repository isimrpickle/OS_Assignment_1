Ο σκελετός της εργασίας στηρίχτηκε σε κώδικα απο το εργαστήριο του μαθήματος semaphore_lab1 "shm_producer.c"καθώς και "shm_consumer.c". Στα include είναι όλες οι βιβλιοθήκες που είναι απαραίτητες για σημαιoφόρους,κοινή μνήμη,threads καθώς και τη συνάρτηση χρόνου gettimeofday() που χρησιμοποιήθηκε για τον υπολογισμό του μέσου χρόνου που λαμβάνει  πακέτο μηνύματος κάποια διεργασία. 

					THREADS:
Το thread producer ορίζεται ως global μεταβλητή ώστε να είναι δυνατή η χρήση της συνάρτησης pthread_cancel() απο το εκάστοτε consumer_thread. Τα threads αρχικοποιούνται και τερματίζουν στη main,2 για κάθε διεργασία.

					SEMAPHORES:
Χρησιμοποιήθηκε unnamed posix semaphore ο οποίος διαμοιράζεται στις 2 διεργασίες μέσω της κοινής μνήμης και αρχικοποιείται/ελευθωρένεται στο B.C 

					Επίτευξη συγχρονισμου:
Για να συγχρονιστούν οι 2 διεργασίες μεταξύ τους, χρησιμοποιήθηκαν flag variables στη κοινή μνήμη (PrintedByA, PrintedByB) σε συνδιασμό με τον σημαιοφόρο. 

					"πακέτα μηνυμάτων"
Το κάθε πακέτο είναι ένας πίνακας χαρακτήρων που βρίσκεται στη κοινή μνήμη ωστέ το input που δίνεται από τη μια διεργασία και σπάει στα πακέτα να είναι δυνατό να το παραλάβει ο consumer_thread της άλλης διεργασίας. Το κάθε producer_thread χωρίζει το μήνυμα ανα πακέτο και το στέλνει κατυθείαν στο consumer_thread της άλλης διεργασίας. Ο συγχρονισμός για αυτά επιτυγχάνεται με το σημαιοφόρο στη κοινή μνήμη, καθώς και με τη χρήση του flag variable της εκάστοτε διεργασίας ( καθώς είναι σε loop μπορεί το sem_post στο τέλος του loop να κατοχυρωνόταν κατευθείαν απο το sem_wait που βρίσκεται στην αρχή του loop).

					"messages received"
Δεν λειτουργουν σωστά, μπορούν να αγνοηθούν

					"messages sent"
Υπάρχει κατάλληλος μετρητής μετά το loop για τα πακέτα. (messagesA,messagesB)

					"packages received"
Υπάρχει κατάλληλος μετρητής στο consumer_thread για τη μέτρηση πακέτων(αυξάνεται κάθε φορά που δέχεται νεο μήνυμα, δηλαδή και νέο πακέτο από το producer_thread της άλλης διεργασίας)

					"packages sent"
Βρίσκεται κατάλληλος μετρητής στα producer_threads (summ_of_packagesB/summ_of_packagesA)

					#BYE#
η λήξη και των 2 διεργασίων με το #BYE# επιτυγχάνεται με τη συνάρτηση pthread_cancel(). Η διεργασία που παίρνει ως input το #BYE# απενεργοποιεί και τα 2 threads φυσικά, χωρίς τη χρήση pthread_cancel. Στη διεργασία που εκτυπώνει το #ΒΥΕ# το consumer_thread τερματίζεται με μια απλή συνθήκη,που όταν εκτελεστεί κάνει το running=0 καθώς και καλεί το pthread_cancel() για να τερματίσει το producer_thread που έχει κολλήσει στο fgets.

					gettimeofday()
Ακολουθώ απλή λογική εύρεσης μέσου όρου,εύρεση αθροίσματος και διαίρεση με το πλήθος οντοτήτων.
Το πλήθος οντωτήτων είναι το εκάστοτε receivedB/receivedA για τη κάθε συνθήκη. Το άθροισμα χρόνου είναι το final_time και βρίσκεται με τη διαφορά της ώρας του τωρινόυ πακέτου που έγινε δεχτό σε σχέση με το προηγούμενο.

					Οδηγίες εκτέλεσης:
make A/ make B για να κάνετε compile τη δειργασία Α/β. 
Εκτέλεση της κάθε διεργασίας με ./A ή ./B

					


